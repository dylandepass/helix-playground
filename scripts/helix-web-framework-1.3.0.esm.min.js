/*
 * Copyright 2022 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 * @preserve
 */
/**
 * Returns a picture element with webp and fallbacks
 * @param {string} src The image URL
 * @param {boolean} eager load image eager
 * @param {Array} breakpoints breakpoints and corresponding params (eg. width)
 * @preserve
 */
function e(e,t="",o=!1,n=[{media:"(min-width: 400px)",width:"2000"},{width:"750"}],a=[]){const i=new URL(e,window.location.href),c=document.createElement("picture");a.length>0&&c.classList.add(a);const{pathname:r}=i,s=r.substring(r.lastIndexOf(".")+1);return n.forEach((e=>{const t=document.createElement("source");e.media&&t.setAttribute("media",e.media),t.setAttribute("type","image/webp"),t.setAttribute("srcset",`${r}?width=${e.width}&format=webply&optimize=medium`),c.appendChild(t)})),n.forEach(((e,a)=>{if(a<n.length-1){const t=document.createElement("source");e.media&&t.setAttribute("media",e.media),t.setAttribute("srcset",`${r}?width=${e.width}&format=${s}&optimize=medium`),c.appendChild(t)}else{const n=document.createElement("img");n.setAttribute("src",`${r}?width=${e.width}&format=${s}&optimize=medium`),n.setAttribute("loading",o?"eager":"lazy"),n.setAttribute("alt",t),c.appendChild(n)}})),c}
/**
 * Given a set of breakpoints, returns the appropriate image URL for the most optimized version.
 * @param {string} src The image URL
 * @param {Array} breakpoints breakpoints and corresponding params (eg. width)
 * @preserve
 */function t(e,t=[{media:"(min-width: 400px)",width:"2000"},{width:"750"}]){const o=new URL(e,window.location.href),{pathname:n}=o,a=n.substring(n.lastIndexOf(".")+1);return`${n}?width=${t[t.length-1].width}&format=${a}&optimize=medium`}
/**
 * Removes formatting from images.
 * @param {Element} main The container element
 * @preserve
 */function o(e){[...e.querySelectorAll("strong picture"),...e.querySelectorAll("em picture")].forEach((e=>{const t=e.closest("p");t.prepend(e),t.lastChild.remove()}))}
/**
 * Decorates a block.
 * @param {Element} block The block element
 * @preserve
 */function n(e){const t=e=>e.replace(/(^\s*-)|(-\s*$)/g,""),o=Array.from(e.classList.values())[0];if(!o)return;const n=e.closest(".section");n&&n.classList.add(`${o}-container`.replace(/--/g,"-"));const a=o.split("--"),i=t(a.shift()),c=a.map((e=>t(e)));e.classList.add(i),e.classList.add(...c),e.classList.add("block"),e.setAttribute("data-block-name",i),e.setAttribute("data-block-status","initialized");e.parentElement.classList.add(`${i}-wrapper`)}
/**
 * Decorates all blocks in a container element.
 * @param {Element} main The container element
 * @preserve
 */function a(e){e.querySelectorAll("div.section-wrapper > div > div").forEach((e=>n(e)))}
/**
 * Sanitizes a name for use as class name.
 * @param {*} name The unsanitized name
 * @returns {string} The class name
 * @preserve
 */function i(e){return e&&"string"==typeof e?e.toLowerCase().replace(/[^0-9a-z]/gi,"-"):""}
/**
 * Extracts the config from a block.
 * @param {Element} block The block element
 * @returns {object} The block config
 * @preserve
 */function c(e){const t={};return e.querySelectorAll(":scope>div").forEach((e=>{if(e.children){const o=[...e.children];if(o[1]){const n=o[1],a=i(o[0].textContent);let c="";if(n.querySelector("a")){const e=[...n.querySelectorAll("a")];c=1===e.length?e[0].href:e.map((e=>e.href))}else if(n.querySelector("p")){const e=[...n.querySelectorAll("p")];c=1===e.length?e[0].textContent:e.map((e=>e.textContent))}else c=e.children[1].textContent;t[a]=c}}})),t}
/**
 * Decorates all sections in a container element.
 * @param {Element} main The container element
 * @preserve
 */function r(e){e.querySelectorAll(":scope > div").forEach((e=>{const t=[];let o=!1;[...e.children].forEach((e=>{if("DIV"===e.tagName||!o){const n=document.createElement("div");t.push(n),o="DIV"!==e.tagName,o&&n.classList.add("default-content-wrapper")}t[t.length-1].append(e)})),t.forEach((t=>e.append(t))),e.classList.add("section"),e.setAttribute("data-section-status","initialized");const n=e.querySelector("div.section-metadata");if(n){const t=c(n);Object.keys(t).forEach((o=>{"style"===o?e.classList.add(i(t.style)):e.dataset[o]=t[o]})),n.remove()}}))}
/**
 * Decorates the picture elements.
 * @param {Element} main The container element
 * @preserve
 */function s(t){t.querySelectorAll('img[src*="/media_"').forEach(((t,o)=>{const n=e(t.src,t.alt,!o),a=t.closest("picture");if(a&&a.parentElement.replaceChild(n,a),["EM","STRONG"].includes(n.parentElement.tagName)){const e=n.parentElement;e.parentElement.replaceChild(n,e)}}))}
/**
 * Normalizes all headings within a container element.
 * @param {Element} elem The container element
 * @param {string[]} allowedHeadings The list of allowed headings (h1 ... h6)
 * @preserve
 */function l(e,t){const o=t.map((e=>e.toLowerCase()));e.querySelectorAll("h1, h2, h3, h4, h5, h6").forEach((e=>{const t=e.tagName.toLowerCase();if(-1===o.indexOf(t)){let n=parseInt(t.charAt(1),10)-1;for(;-1===o.indexOf(`h${n}`)&&n>0;)n-=1;if(0===n)for(;-1===o.indexOf(`h${n}`)&&n<7;)n+=1;7!==n&&(e.outerHTML=`<h${n}>${e.textContent}</h${n}>`)}}))}
/**
 * Adds the favicon.
 * @param {string} href The favicon URL
 * @preserve
 */function d(e){const t=document.createElement("link");t.rel="icon",t.type="image/svg+xml",t.href=e;const o=document.querySelector('head link[rel="icon"]');o?o.parentElement.replaceChild(t,o):document.getElementsByTagName("head")[0].appendChild(t)}
/**
 * Turns absolute links within the domain into relative links.
 * @param {Element} main The container element
 * @preserve
 */function u(e,t){e.querySelectorAll("a").forEach((e=>{const o=["hlx.page","hlx.live",...t];if(e.href)try{const t=new URL(e.href);o.some((e=>t.hostname.includes(e)))&&(e.href=`${t.pathname}${t.search}${t.hash}`)}catch(e){console.log(e)}}))}
/**
 * loads a script by adding a script tag to the head.
 * @param {string} url URL of the js file
 * @param {Function} callback callback on load
 * @param {string} type type attribute of script tag
 * @returns {Element} script element
 * @preserve
 */function h(e,t,o){const n=document.querySelector("head"),a=document.createElement("script");return a.setAttribute("src",e),o&&a.setAttribute("type",o),n.append(a),a.onload=t,a}
/**
 * Loads a CSS file.
 * @param {string} href The path to the CSS file
 * @preserve
 */function m(e,t){if(document.querySelector(`head > link[href="${e}"]`))"function"==typeof t&&t("noop");else{const o=document.createElement("link");o.setAttribute("rel","stylesheet"),o.setAttribute("href",e),"function"==typeof t&&(o.onload=e=>t(e.type),o.onerror=e=>t(e.type)),document.head.appendChild(o)}}
/**
 * Updates all section status in a container element.
 * @param {Element} main The container element
 * @preserve
 */function f(e){const t=[...e.querySelectorAll(":scope > div.section-wrapper")];for(let e=0;e<t.length;e+=1){const o=t[e];if("loaded"!==o.getAttribute("data-section-status")){if(o.querySelector('.block[data-block-status="initialized"], .block[data-block-status="loading"]')){o.setAttribute("data-section-status","loading");break}o.setAttribute("data-section-status","loaded")}}}
/**
 * Loads JS and CSS for a block.
 * @param {Element} block The block element
 * @preserve
 */async function p(e,t=!1){if("loading"!==e.getAttribute("data-block-status")&&"loaded"!==e.getAttribute("data-block-status")){e.setAttribute("data-block-status","loading");const o=e.getAttribute("data-block-name");try{const n=new Promise((e=>{m(`${window.hlx.codeBasePath}/blocks/${o}/${o}.css`,e)})),a=new Promise((n=>{(async()=>{try{const n=await import(`../blocks/${o}/${o}.js`);n.default&&await n.default(e,o,document,t)}catch(e){console.log(`failed to load module for ${o}`,e)}n()})()}));await Promise.all([n,a])}catch(e){console.log(`failed to load block ${o}`,e)}e.setAttribute("data-block-status","loaded")}}
/**
 * Loads JS and CSS for all blocks in a container element.
 * @param {Element} main The container element
 * @preserve
 */async function w(e){f(e);const t=[...e.querySelectorAll("div.block")];for(let o=0;o<t.length;o+=1)await p(t[o]),f(e)}
/**
 * Builds a block DOM Element from a two dimensional array
 * @param {string} blockName name of the block
 * @param {any} content two dimensional array or string or object of content
 * @preserve
 */function g(e,t){const o=Array.isArray(t)?t:[[t]],n=document.createElement("div");return n.classList.add(e),o.forEach((e=>{const t=document.createElement("div");e.forEach((e=>{const o=document.createElement("div");(e.elems?e.elems:[e]).forEach((e=>{e&&("string"==typeof e?o.innerHTML+=e:o.appendChild(e))})),t.appendChild(o)})),n.appendChild(t)})),n}
/**
 * Loads the header block.
 * @param {Element} header The header element
 * @preserve
 */async function y(e,t){const o=g("header","");e.append(o),n(o),await p(o),u(o,t)}
/**
 * Loads the footer block.
 * @param {Element} footer The footer element
 * @preserve
 */async function b(e,t){const o=g("footer","");e.append(o),n(o),await p(o),u(o,t)}
/**
 * load LCP block and/or wait for LCP in default content.
 * @preserve
 */async function A(e){const t=e,o=document.querySelector(".block");o&&t.includes(o.getAttribute("data-block-name"))&&await p(o,!0),document.querySelector("body").classList.add("appear");const n=document.querySelector("main img");await new Promise((e=>{n&&!n.complete?(n.setAttribute("loading","eager"),n.addEventListener("load",(()=>e())),n.addEventListener("error",(()=>e()))):e()}))}
/**
 * Retrieves the content of a metadata tag.
 * @param {string} name The metadata name (or property)
 * @returns {string} The metadata value
 * @preserve
 */function E(e){const t=e&&e.includes(":")?"property":"name",o=document.head.querySelector(`meta[${t}="${e}"]`);return o&&o.content}
/**
 * log RUM if part of the sample.
 * @param {string} checkpoint identifies the checkpoint in funnel
 * @param {Object} data additional data for RUM sample
 * @preserve
 */function $(e,t,o={}){try{if(window.hlx=window.hlx||{},!window.hlx.rum){const e="on"===new URLSearchParams(window.location.search).get("rum")?1:100,t=`${(e=>e.split("").reduce(((e,t)=>(e<<5)-e+t.charCodeAt(0)|0),0))(window.location.href)}-${(new Date).getTime()}-${Math.random().toString(16).substr(2,14)}`,o=Math.random(),n=o*e<1;window.hlx.rum={weight:e,id:t,random:o,isSelected:n}}const{random:n,weight:a,id:i}=window.hlx.rum;if(n&&n*a<1){const n=()=>{const n=JSON.stringify({weight:a,id:i,referer:window.location.href,generation:t,checkpoint:e,...o}),c=`https://rum.hlx.page/.rum/${a}`;navigator.sendBeacon(c,n)};if(n(),"cwv"===e){const e=document.createElement("script");e.src="https://rum.hlx.page/.rum/web-vitals/dist/web-vitals.iife.js",e.onload=()=>{const e=e=>{o.cwv={},o.cwv[e.name]=e.value,n()};window.webVitals.getCLS(e),window.webVitals.getFID(e),window.webVitals.getLCP(e)},document.head.appendChild(e)}}}catch(e){}}function S(e){window.name.includes("performance")&&console.log(`${new Date-performance.timing.navigationStart}:${e}`)}function v(){try{new PerformanceObserver((e=>{const t=e.getEntries();S(JSON.stringify(t)),console.log(t[0].element)})).observe({type:"largest-contentful-paint",buffered:!0});new PerformanceObserver((e=>{const t=e.getEntries();S(JSON.stringify(t)),console.log(t[0].sources[0].node)})).observe({type:"layout-shift",buffered:!0});new PerformanceObserver((e=>{e.getEntries().forEach((e=>{S(`resource loaded: ${e.name} - [${Math.round(e.startTime+e.duration)}]`)}))})).observe({type:"resource",buffered:!0})}catch(e){}}
/**
 * Initializes helix
 * @preserve
 */function x(){window.hlx=window.hlx||{},window.hlx.lighthouse="on"===new URLSearchParams(window.location.search).get("lighthouse"),window.hlx.codeBasePath="";const e=document.querySelector('script[src$="/scripts/scripts.js"]');if(e)try{[window.hlx.codeBasePath]=new URL(e.src).pathname.split("/scripts/scripts.js")}catch(e){console.log(e)}}
/**
 * Adds one or more URLs to the dependencies for publishing.
 * @param {string|string[]} url The URL(s) to add as dependencies
 * @preserve
 */function k(e){const t=Array.isArray(e)?e:[e];window.hlx=window.hlx||{},window.hlx.dependencies&&Array.isArray(window.hlx.dependencies)?window.hlx.dependencies.concat(t):window.hlx.dependencies=t}class L{constructor(e){this.config=e,this.rumEnabled=!1,x(),this.rumEnabled&&(this.sampleRUM("top"),window.addEventListener("load",(()=>$("load"))),document.addEventListener("click",(()=>$("click")))),this.loadPage(document),window.name.includes("performance")&&v()}
/**
   * log RUM if part of the sample.
   * @param {string} checkpoint identifies the checkpoint in funnel
   * @param {Object} data additional data for RUM sample
   * @preserve
   */sampleRUM(e,t={}){$(e,this.config.rumGeneration,t)}async loadPage(e){await this.loadEager(e),await this.loadLazy(e),this.loadDelayed(e)}async loadEager(e){const t=e.querySelector("main");t&&(this.decorateMain(t),await this.waitForLCP(this.config.lcpBlocks))}decorateMain(e){this.decoratePictures(e),this.makeLinksRelative(e,this.config.productionDomains),this.removeStylingFromImages(e),this.buildAutoBlocks(e),this.decorateSections(e),this.decorateBlocks(e)}async loadLazy(e){const t=e.querySelector("main");await w(t),this.loadHeader(e.querySelector("header")),this.loadFooter(e.querySelector("footer")),m(`${window.hlx.codeBasePath}/styles/lazy-styles.css`),d(`${window.hlx.codeBasePath}/icon.svg`)}loadDelayed(){}buildAutoBlocks(e){}async loadHeader(e){y(e,this.config.productionDomains)}async loadFooter(e){b(e,this.config.productionDomains)}removeStylingFromImages(e){o(e)}makeLinksRelative(e,t){u(e,t)}decorateSections(e){r(e)}decorateBlocks(e){a(e)}decoratePictures(e){s(e)}
/**
   * load LCP block and/or wait for LCP in default content.
   * @preserve
   */waitForLCP(e){return A(e)}}export{L as HelixApp,d as addFavIcon,k as addPublishDependencies,g as buildBlock,e as createOptimizedPicture,n as decorateBlock,a as decorateBlocks,s as decoratePictures,r as decorateSections,E as getMetadata,t as getOptimizedImagePath,x as initHlx,p as loadBlock,w as loadBlocks,m as loadCSS,b as loadFooter,y as loadHeader,h as loadScript,u as makeLinksRelative,l as normalizeHeadings,c as readBlockConfig,v as registerPerformanceLogger,o as removeStylingFromImages,$ as sampleRUM,S as stamp,i as toClassName,f as updateSectionsStatus,A as waitForLCP};
